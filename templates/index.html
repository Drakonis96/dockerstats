<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Docker Monitor</title>
  <link rel="icon" href="{{ url_for('static', filename='logo.png') }}">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.2/dist/chart.umd.min.js"></script> <!-- Add Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.2.0/dist/chartjs-plugin-zoom.min.js"></script> <!-- Chart.js Zoom plugin -->
  <style>
    /* Transparent header matching body */
    nav.navbar {
        /* Use Bootstrap background variable for theme compatibility */
        background-color: var(--bs-body-bg) !important;
        padding: 0.5rem 1rem; /* Adjust padding */
        /* Add a subtle shadow */
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        height: 60px; /* Set a fixed height for the new navbar */
    }
    /* Container within navbar */
    nav.navbar .container-fluid { /* Use container-fluid for full width */
      display: flex;
      align-items: center;
      justify-content: space-between; /* Space out left and right groups */
      height: 100%;
    }
    /* Logo smaller */
    nav.navbar img {
      width: 40px; /* Smaller logo */
      height: 40px; /* Smaller logo */
      margin-right: 0.5rem; /* Space between logo and title */
    }
    /* Title Style */
    .navbar-title {
        font-size: 1.25rem; /* Adjust size as needed */
        font-weight: bold;
        text-transform: uppercase;
        color: var(--bs-body-color); /* Use theme color */
        margin-right: auto; /* Push search/buttons to the right */
    }
    /* Search input style */
    #navbarSearchInput {
        width: 250px; /* Adjust width */
        margin-right: 1rem; /* Space before buttons */
    }
    /* Navbar buttons */
    .navbar-buttons .btn {
        margin-left: 0.5rem; /* Space between buttons */
        font-size: 1.2rem; /* Adjust icon size */
        padding: 0.25rem 0.5rem; /* Adjust padding */
        line-height: 1; /* Ensure vertical alignment */
    }
    /* Adjust page content down by header height + margin */
    body {
      padding-top: calc(60px + 1rem); /* Match new header height */
      padding-bottom: 5rem; /* Add space at the bottom */
      padding-left: 1rem;
      padding-right: 1rem;
      transition: background .3s, color .3s;
    }

    /* Desktop: wrap cells and use full width */
    @media (min-width: 768px) {
      #metricsTable {
        table-layout: auto;
        width: 100%;
      }
      #metricsTable th,
      #metricsTable td {
        white-space: normal;
        overflow-wrap: anywhere;
      }
    }
    /* Mobile: prevent wrapping and enable horizontal scroll */
    @media (max-width: 767.98px) {
      #metricsTable {
        table-layout: auto;
        width: auto;
      }
      #metricsTable th,
      #metricsTable td {
        white-space: nowrap !important;
      }
      #tableView {
        overflow-x: auto;
      }
      body {
        padding-top: 130px; /* Adjust this value as needed */
      }
    }

    /* Controls & table styling */
    .form-control, .form-select, .form-check-input {
      transition: background .3s, color .3s, border-color .3s;
    }
    .form-control::placeholder { color: #6c757d; transition: color .3s; } /* Bootstrap secondary color */
    .table, .table th, .table td {
      transition: background .3s, color .3s;
      white-space: nowrap; /* Prevent wrapping in table cells */
    }
     .table th, .table td {
        padding: 0.5rem; /* Adjust padding */
        vertical-align: middle; /* Vertical centering for all */
        white-space: nowrap; /* Prevent text wrapping */
    }
     /* Progress bar styling */
     .progress {
        height: 12px; /* Slightly thicker progress bar */
        margin-bottom: 0; /* Remove default margin */
        background-color: #e9ecef; /* Light background for contrast */
        border-radius: .25rem;
        overflow: hidden;
        /* width: 100%; Ensure progress bar takes full width of cell */
     }
     .progress-bar {
         transition: width .6s ease;
         font-size: 0.7rem; /* Smaller text inside bar if needed */
         line-height: 12px; /* Match height */
         color: white;
         text-align: center;
         white-space: nowrap;
         background-color: #7b4acf !important; /* custom progress color */
         /* Colors set by bg-* classes */
     }
     /* Space below percentage text */
     td.col-cpu span, td.col-ram span {
        display: block;
        margin-bottom: 3px; /* Small space */
        text-align: right; /* Keep percentage right aligned */
        font-size: 0.9em; /* Slightly smaller text for percentage */
     }

     /* --- Text Alignment by Column --- */
     /* Default: Left (Name, Image, Ports) */
     #metricsTable th,
     #metricsTable td { text-align: left; }
     #metricsTable th.col-name, #metricsTable td.col-name,
     #metricsTable th.col-image, #metricsTable td.col-image,
     #metricsTable th.col-ports, #metricsTable td.col-ports { text-align: left; }
     /* Right for numeric data + uptime (using fixed width helps) */
     #metricsTable th.col-cpu, #metricsTable td.col-cpu,
     #metricsTable th.col-ram, #metricsTable td.col-ram,
     #metricsTable th.col-uptime, #metricsTable td.col-uptime,
     #metricsTable th.col-netio, #metricsTable td.col-netio,
     #metricsTable th.col-blockio, #metricsTable td.col-blockio,
     #metricsTable th.col-restarts, #metricsTable td.col-restarts,
     #metricsTable th.col-pid, #metricsTable td.col-pid,
     #metricsTable th.col-memlimit, #metricsTable td.col-memlimit { text-align: right; }
     #metricsTable td.col-uptime { font-family: monospace; font-size: 0.9em; } /* Monospace for uptime alignment */
     /* Center for Status */
     #metricsTable th.col-status, #metricsTable td.col-status { text-align: center; }
     /* Center for Charts (Chart button) */
     #metricsTable th.col-charts, #metricsTable td.col-charts { text-align: center; }
     /* Center for UI */
     #metricsTable th.col-ui, #metricsTable td.col-ui { text-align: center; }
     /* Center for Actions */
     #metricsTable th.col-actions, #metricsTable td.col-actions { text-align: center; }
     /* Center for Update */
     #metricsTable th.col-update, #metricsTable td.col-update { text-align: center; }

    /* Dark mode */
    [data-bs-theme="dark"] body { /* Target Bootstrap 5.3+ dark mode */
      background: #1c1c1c; /* Slightly off-black */
      color: #e0e0e0; /* Light gray */
    }
    [data-bs-theme="dark"] .form-control, [data-bs-theme="dark"] .form-select {
      background: #2a2a2a;
      color: #e0e0e0;
      border-color: #555; /* Slightly lighter border */
    }
    [data-bs-theme="dark"] .form-control::placeholder { color: #aaa; }
    [data-bs-theme="dark"] .table, [data-bs-theme="dark"] th, [data-bs-theme="dark"] td {
      color: #e0e0e0;
      border-color: #444;
    }
     /* Striping overrides */
     [data-bs-theme="dark"] .table-striped>tbody>tr:nth-of-type(odd)>* {
       background-color: #232323 !important; /* Darker stripe */
       color: #e0e0e0;
    }
     [data-bs-theme="dark"] .table-striped>tbody>tr:nth-of-type(even)>* {
       background-color: #2a2a2a !important; /* Lighter stripe */
       color: #e0e0e0;
    }
     /* Dark mode progress bar background */
     [data-bs-theme="dark"] .progress {
         background-color: #555; /* Darker background */
     }
    [data-bs-theme="dark"] .form-check-input {
        background-color: #2a2a2a;
        border-color: #555;
    }
    [data-bs-theme="dark"] .form-check-input:checked {
        background-color: #0d6efd; /* Bootstrap primary blue */
        border-color: #0d6efd;
    }
    [data-bs-theme="dark"] .form-check-label {
        color: #e0e0e0; /* Ensure label text is visible */
    }

    [data-bs-theme="dark"] #statusMessageArea {
      background: #232323 !important;
      color: #fff !important;
    }

    /* Floating buttons */
    #scrollTop { /* Keep scroll top fixed */
      position: fixed;
      bottom: 1rem;
      right: 1rem; /* Adjust position if needed */
      width: 3rem;
      height: 3rem;
      font-size: 1.5rem;
      line-height: 3rem;
      text-align: center;
      border-radius: 50%;
      background: rgba(var(--bs-body-bg-rgb, 255, 255, 255), 0.8);
      color: var(--bs-body-color, #333);
      cursor: pointer;
      z-index: 1050;
      transition: background .3s, color .3s, transform 0.2s;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
      border: 1px solid rgba(var(--bs-emphasis-color-rgb, 0, 0, 0), 0.1);
      padding: 0;
    }
     #scrollTop:hover {
        transform: scale(1.1);
     }

    /* Notification panel styling - Position below header button */
    #notifPanel {
      display: none;
      position: absolute; /* Position relative to nearest positioned ancestor (navbar) */
      top: 100%; /* Position below the navbar */
      right: 0; /* Align with the right edge of the button's container */
      width: 300px;
      max-height: 400px;
      overflow-y: auto;
      background: var(--bs-body-bg);
      color: var(--bs-body-color);
      border: 1px solid var(--bs-border-color-translucent);
      border-radius: .375rem;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
      padding: 1rem;
      z-index: 1060; /* Ensure above content, below modals if any */
      margin-top: 0.5rem; /* Small gap below the button */
    }
    /* Container for notification button to position panel correctly */
    .navbar-buttons .position-relative {
        position: relative; /* Needed for absolute positioning of the panel */
    }

    /* Column visibility toggles */
    .column-toggles .form-check {
        display: inline-block;
        margin-right: 10px;
        margin-bottom: 5px;
    }
    .column-toggles {
        margin-bottom: 1rem;
        padding: 0.75rem 1rem; /* More padding */
        border: 1px solid var(--bs-border-color-translucent, rgba(0,0,0,0.1));
        border-radius: 0.375rem;
        background: rgba(var(--bs-secondary-bg-rgb), 0.1); /* Subtle background */
    }
     .column-toggles strong {
        margin-right: 10px;
     }

     /* --- Mobile Adjustments --- */
     @media (max-width: 767.98px) {
        /* Header adjustments */
        nav.navbar .container-fluid {
            flex-wrap: wrap; /* Allow items to wrap */
            justify-content: space-between;
        }
        .navbar-title {
            margin-right: 0; /* Remove auto margin */
            margin-bottom: 0.5rem; /* Add space below title when wrapped */
            flex-basis: 100%; /* Make title take full width initially */
            text-align: center; /* Center title on mobile */
        }
        .navbar-buttons {
            width: 100%; /* Make search/buttons take full width */
            justify-content: space-between; /* Space out search and buttons */
            margin-top: 0.5rem; /* Space above search/buttons */
        }
        #navbarSearchInput {
            width: auto; /* Allow search to shrink/grow */
            flex-grow: 1; /* Allow search to take available space */
            margin-right: 0.5rem; /* Smaller margin */
        }
        .navbar-buttons .btn {
            font-size: 1rem; /* Slightly smaller icons */
            padding: 0.2rem 0.4rem;
        }
        nav.navbar {
            height: auto; /* Allow header height to adjust */
            padding-bottom: 0.5rem; /* Add padding at bottom when wrapped */
        }
        body {
             padding-top: 130px; /* Adjust this value as needed */
        }

        /* Action buttons row adjustments */
        .action-buttons-row .col-12 > * { /* Target direct children of the column */
            margin-bottom: 0.5rem; /* Add space below each button/group */
            margin-right: 0.5rem; /* Add space between buttons */
        }
        .action-buttons-row .col-12 {
            display: flex;
            flex-wrap: wrap; /* Allow buttons to wrap */
            align-items: center;
        }
        /* Ensure comparison group stays together */
        .comparison-controls {
            display: inline-flex; /* Keep dropdown and input together */
            align-items: center;
            margin-left: 0.5rem; /* Space before comparison controls */
        }
        #compareTopN {
            width: 4.5rem; /* Keep width */
            margin-left: 0.5rem; /* Space between dropdown and input */
        }

        /* Table view scroll */
        #tableView {
            overflow-x: auto;
        }
        #metricsTable {
            table-layout: auto;
            width: auto; /* Allow table to be wider than screen */
        }
        #metricsTable th,
        #metricsTable td {
            white-space: nowrap !important;
        }
     }

     /* --- Chart Container Styling --- */
     #chartContainer {
        margin-top: 1rem; /* Reduced margin */
        padding: 0.5rem; /* Further reduced padding */
        border: 1px solid var(--bs-border-color-translucent, rgba(0,0,0,0.1));
        border-radius: 0.375rem;
        background: rgba(var(--bs-secondary-bg-rgb), 0.05);
        max-height: 500px; /* Significantly reduced container height */
        display: none; /* Initially hidden */
        overflow: hidden; /* Hide potential overflow */
     }
     #chartContainer h5 {
        margin-bottom: 0.25rem; /* Reduced margin */
        font-size: 0.9rem; /* Smaller title */
        text-align: center;
     }
     #chartContainer canvas { /* Ensure canvas respects container height */
        max-height: 360px; /* Significantly reduced max-height for the canvas */
     }
     #chartControls {
        text-align: center;
        margin-bottom: 0.25rem; /* Reduced margin */
     }
     #chartControls .btn-group {
        margin-bottom: 0.25rem; /* Space below buttons */
     }
     #chartControls .btn-sm {
        padding: 0.15rem 0.4rem; /* Smaller buttons */
        font-size: 0.8rem;
     }

     /* Footer Styling */
     .footer {
        padding: 1rem 0;
        margin-top: 2rem; /* Space above footer */
        text-align: center;
        font-size: 0.9em;
        color: var(--bs-secondary-color); /* Use Bootstrap secondary text color */
        border-top: 1px solid var(--bs-border-color-translucent); /* Subtle top border */
     }

     /* Style Save Settings button */
     #saveSettingsBtn {
       background-color: #7a49cd !important;
       border-color: #7a49cd !important;
     }

     /* Status Message Area Styling */
     #statusMessageArea {
        margin-top: 0.5rem; /* Space above the message */
        min-height: 1.5em; /* Prevent layout shifts when empty */
        font-weight: 500; /* Slightly bolder text */
     }

     /* Evitar que las columnas se encojan: layout fijo y ancho según contenido */
     #metricsTable {
       table-layout: fixed; /* Removed !important */
       width: max-content !important; /* Ancho según el contenido mínimo */
     }
     #metricsTable th,
     #metricsTable td {
       min-width: 120px; /* Ajusta este valor a tu preferencia */
     }

     /* Asegura scroll horizontal siempre que el contenido exceda el viewport */
     .table-responsive {
       overflow-x: auto;
     }

     /* Column visibility CSS - Add classes to hide columns */
     /* Using !important might be needed if other styles conflict, but try without first */
     /* Apply display: none when the corresponding hide class is on the TABLE element */
     .hide-col-name th.col-name, .hide-col-name td.col-name { display: none; }
     .hide-col-cpu th.col-cpu, .hide-col-cpu td.col-cpu { display: none; }
     .hide-col-ram th.col-ram, .hide-col-ram td.col-ram { display: none; }
     .hide-col-pid th.col-pid, .hide-col-pid td.col-pid { display: none; }
     .hide-col-memlimit th.col-memlimit, .hide-col-memlimit td.col-memlimit { display: none; }
     .hide-col-status th.col-status, .hide-col-status td.col-status { display: none; }
     .hide-col-uptime th.col-uptime, .hide-col-uptime td.col-uptime { display: none; }
     .hide-col-netio th.col-netio, .hide-col-netio td.col-netio { display: none; }
     .hide-col-blockio th.col-blockio, .hide-col-blockio td.col-blockio { display: none; }
     .hide-col-image th.col-image, .hide-col-image td.col-image { display: none; }
     .hide-col-ports th.col-ports, .hide-col-ports td.col-ports { display: none; }
     .hide-col-restarts th.col-restarts, .hide-col-restarts td.col-restarts { display: none; }
     .hide-col-logs th.col-logs, .hide-col-logs td.col-logs { display: none; }
     .hide-col-charts th.col-charts, .hide-col-charts td.col-charts { display: none; }
     .hide-col-ui th.col-ui, .hide-col-ui td.col-ui { display: none; }
     .hide-col-actions th.col-actions, .hide-col-actions td.col-actions { display: none; }
     .hide-col-update th.col-update, .hide-col-update td.col-update { display: none; }

  </style>
</head>
<body data-bs-theme="light">
  <nav class="navbar fixed-top">
    <div class="container-fluid">
      <!-- Left side: Logo and Title -->
      <div class="d-flex align-items-center">
        <img src="{{ url_for('static', filename='logo.png') }}" alt="Docker Monitor Logo">
        <span class="navbar-title">Docker Stats</span>
      </div>

      <!-- Right side: Search and Buttons -->
      <div class="d-flex align-items-center navbar-buttons">
        <input type="search" id="navbarSearchInput" class="form-control form-control-sm" placeholder="Search containers...">
        <!-- Wrap notification button in a relative div for panel positioning -->
        <div class="position-relative">
            <button type="button" id="notifToggle" class="btn btn-outline-secondary" aria-label="Notifications">
              🔔
              <span id="notifBadge" class="badge bg-danger position-absolute top-0 start-100 translate-middle" style="display:none; font-size:0.6rem; padding: 0.2em 0.4em;"></span>
            </button>
            <!-- Notification Panel moved inside relative container -->
            <div id="notifPanel">
                <h5>Notifications</h5>
                <div id="notifConfig" class="mb-2">
                  <h6>Settings</h6>
                  <div class="mb-1"><label class="form-label">CPU Threshold (%): <input type="number" id="notifCpuThreshold" class="form-control form-control-sm" min="0" max="100"></label></div>
                  <div class="mb-1"><label class="form-label">RAM Threshold (%): <input type="number" id="notifRamThreshold" class="form-control form-control-sm" min="0" max="100"></label></div>
                  <div class="form-check mb-2"><input class="form-check-input" type="checkbox" id="notifStatusChange"><label class="form-check-label" for="notifStatusChange">Status Change</label></div>
                  <button type="button" id="saveNotifSettingsBtn" class="btn btn-sm btn-primary">Save</button>
                </div>
                <div id="notifList" class="mb-2"><p class="small text-muted">No notifications</p></div>
                <button type="button" id="clearNotifsBtn" class="btn btn-sm btn-secondary">Clear Notifications</button>
            </div>
        </div>
        <button type="button" id="themeToggle" class="btn btn-outline-secondary" aria-label="Toggle theme">🌙</button>
      </div>
    </div>
  </nav>

  <!-- ScrollTop button remains outside the nav -->
  <button type="button" id="scrollTop" aria-label="Scroll to top">⬆️</button>
  <!-- Notification Panel HTML is now inside the navbar's relative div -->

  <div class="container-fluid px-3">
    <div class="row g-3 mb-3 align-items-center">
      <div class="col-lg-2 col-md-4 col-sm-6"><input id="filterName" class="form-control form-control-sm" placeholder="Filter by name"></div>
      <div class="col-lg-2 col-md-4 col-sm-6">
        <select id="filterStatus" class="form-select form-select-sm" aria-label="Filter by status">
          <option value="">All statuses</option>
          <option value="running">Running</option>
          <option value="exited">Exited</option>
          <option value="created">Created</option>
          <option value="restarting">Restarting</option>
          <option value="paused">Paused</option>
          <option value="error-sample">Error Sampling</option>
          <option value="unknown">Unknown</option>
        </select>
      </div>
      <div class="col-lg-2 col-md-4 col-sm-6">
        <select id="filterProject" class="form-select form-select-sm" aria-label="Filter by project">
          <option value="">All Projects</option>
        </select>
      </div>
      <div class="col-lg-2 col-md-4 col-sm-6">
        <select id="filterRange" class="form-select form-select-sm" aria-label="Filter by time range (History window)">
          <option value="300">Last 5 minutes</option>
          <option value="900">Last 15 minutes</option>
          <option value="1800">Last 30 minutes</option>
          <option value="3600">Last 1 hour</option>
          <option value="7200">Last 2 hours</option>
          <option value="14400">Last 4 hours</option>
          <option value="21600">Last 6 hours</option>
          <option value="43200">Last 12 hours</option>
          <option value="86400" selected>Last 24 hours</option>
        </select>
      </div>
      <!-- Add Refresh Interval Dropdown -->
      <div class="col-lg-2 col-md-4 col-sm-6">
        <select id="refreshInterval" class="form-select form-select-sm" aria-label="Select refresh interval">
          <option value="5000" selected>Refresh every 5s</option>
          <option value="10000">Refresh every 10s</option>
          <option value="15000">Refresh every 15s</option>
          <option value="30000">Refresh every 30s</option>
          <option value="60000">Refresh every 60s</option>
          <option value="75000">Refresh every 75s</option>
        </select>
      </div>
      <!-- End Refresh Interval Dropdown -->
      <div class="col-lg-2 col-md-4 col-sm-6">
        <select id="sortBy" class="form-select form-select-sm" aria-label="Sort by column">
          <option value="name">Sort by Name</option>
          <option value="cpu">Sort by CPU %</option>
          <option value="mem">Sort by RAM %</option>
          <option value="pid_count">Sort by Procs</option> <!-- Added -->
          <option value="combined" selected>Sort by Combined %</option>
          <option value="status">Sort by Status</option>
          <option value="uptime_sec">Sort by Uptime</option>
          <option value="restarts">Sort by Restarts</option>
          <option value="mem_limit">Sort by Mem Limit</option> <!-- Changed value -->
          <option value="net_io_rx">Sort by Net I/O (Rx)</option> <!-- Added -->
          <option value="block_io_r">Sort by Block I/O (R)</option> <!-- Added -->
          <option value="update_available">Sort by Updates</option> <!-- Added -->
        </select>
      </div>
      <div class="col-lg-1 col-md-2 col-sm-3">
        <select id="sortDir" class="form-select form-select-sm" aria-label="Sort direction">
          <option value="asc">Asc</option>
          <option value="desc" selected>Desc</option>
        </select>
      </div>
      <div class="col-lg-2 col-md-4 col-sm-6">
        <input id="maxItems" type="number" min="1" value="25" class="form-control form-control-sm" placeholder="Max items" aria-label="Max items">
      </div>
      <div class="col-lg-2 col-md-4 col-sm-6">
        <input id="serverIP" class="form-control form-control-sm" placeholder="Server IP (e.g., 127.0.0.1)" aria-label="Server IP">
      </div>
      <div class="col-lg-1 col-md-2 col-sm-3 d-flex align-items-center">
        <div class="form-check form-check-inline">
          <input id="useCustomIP" class="form-check-input align-middle" type="checkbox">
          <label class="form-check-label mb-0 align-middle" for="useCustomIP">Use Custom IP</label>
        </div>
      </div>  <!-- End maxItems/IP cols -->
    </div>

     <div class="row mb-3">
        <div class="col-12">
            <div class="column-toggles">
                <strong>Show columns:</strong>
                <div class="form-check form-check-inline">
                    <input class="form-check-input" type="checkbox" value="cpu" id="toggleColCPU" checked>
                    <label class="form-check-label" for="toggleColCPU">CPU %</label>
                </div>
                <div class="form-check form-check-inline">
                    <input class="form-check-input" type="checkbox" value="ram" id="toggleColRAM" checked>
                    <label class="form-check-label" for="toggleColRAM">RAM %</label>
                </div>
                <div class="form-check form-check-inline">
                    <input class="form-check-input" type="checkbox" value="pid" id="toggleColPID" checked>
                    <label class="form-check-label" for="toggleColPID">Procs</label>
                </div>
                <div class="form-check form-check-inline">
                    <input class="form-check-input" type="checkbox" value="memlimit" id="toggleColMemlimit" checked>
                    <label class="form-check-label" for="toggleColMemlimit">Mem Limit (MB)</label>
                </div>
                 <div class="form-check form-check-inline">
                    <input class="form-check-input" type="checkbox" value="status" id="toggleColStatus" checked>
                    <label class="form-check-label" for="toggleColStatus">Status</label>
                </div>
                 <div class="form-check form-check-inline">
                    <input class="form-check-input" type="checkbox" value="uptime" id="toggleColUptime" checked>
                    <label class="form-check-label" for="toggleColUptime">Uptime (D H M S)</label>
                </div>
                 <div class="form-check form-check-inline">
                    <input class="form-check-input" type="checkbox" value="netio" id="toggleColNetIO">
                    <label class="form-check-label" for="toggleColNetIO">Net I/O</label>
                </div>
                 <div class="form-check form-check-inline">
                    <input class="form-check-input" type="checkbox" value="blockio" id="toggleColBlockIO">
                    <label class="form-check-label" for="toggleColBlockIO">Block I/O</label>
                </div>
                 <div class="form-check form-check-inline">
                    <input class="form-check-input" type="checkbox" value="image" id="toggleColImage">
                    <label class="form-check-label" for="toggleColImage">Image</label>
                </div>
                 <div class="form-check form-check-inline">
                    <input class="form-check-input" type="checkbox" value="ports" id="toggleColPorts">
                    <label class="form-check-label" for="toggleColPorts">Ports</label>
                </div>
                 <div class="form-check form-check-inline">
                    <input class="form-check-input" type="checkbox" value="restarts" id="toggleColRestarts">
                    <label class="form-check-label" for="toggleColRestarts">Restarts</label>
                </div>
                 <div class="form-check form-check-inline">
                    <input class="form-check-input" type="checkbox" value="logs" id="toggleColLogs" checked>
                    <label class="form-check-label" for="toggleColLogs">Logs</label>
                </div>
                 <div class="form-check form-check-inline">
                    <input class="form-check-input" type="checkbox" value="charts" id="toggleColCharts" checked>
                    <label class="form-check-label" for="toggleColCharts">Charts</label>
                </div>
                <div class="form-check form-check-inline">
                    <input class="form-check-input" type="checkbox" value="ui" id="toggleColUI" checked>
                    <label class="form-check-label" for="toggleColUI">UI</label>
                </div>
                <div class="form-check form-check-inline">
                    <input class="form-check-input" type="checkbox" value="actions" id="toggleColActions" checked>
                    <label class="form-check-label" for="toggleColActions">Actions</label>
                </div>
                <div class="form-check form-check-inline">
                    <input class="form-check-input" type="checkbox" value="update" id="toggleColUpdate" checked>
                    <label class="form-check-label" for="toggleColUpdate">Update</label>
                </div>
            </div>
        </div>
    </div>
    <!-- Action Buttons Row -->
    <div class="row mb-3 action-buttons-row">
      <div class="col-12">
        <button id="saveSettingsBtn" class="btn btn-primary btn-sm">💾 Save Settings</button>
        <button id="checkUpdatesBtn" class="btn btn-warning btn-sm ms-2">🔄 Check Updates</button>
        <button id="toggleColsBtn" class="btn btn-secondary btn-sm ms-2">🔄 Select/Deselect All</button>
        <button id="exportCsvBtn" class="btn btn-secondary btn-sm ms-2">📤 Export CSV</button>
        <!-- Comparison controls moved here -->
        <div class="comparison-controls d-inline-flex align-items-center ms-2">
          <div class="dropdown">
            <button class="btn btn-secondary btn-sm dropdown-toggle" type="button" id="compareDropdown" data-bs-toggle="dropdown" aria-expanded="false">
              📊 Comparison graphs
            </button>
            <ul class="dropdown-menu" aria-labelledby="compareDropdown">
              <li><a class="dropdown-item compare-action" href="#" data-compare-type="usage">CPU/RAM Usage</a></li>
              <li><a class="dropdown-item compare-action" href="#" data-compare-type="uptime">Uptime</a></li>
            </ul>
          </div>
          <input id="compareTopN" type="number" min="1" value="10" class="form-control form-control-sm ms-1" placeholder="Top N" aria-label="Top N" style="width: 4.5rem;">
        </div>
        <!-- End comparison controls -->
        <!-- Status Message Area - Changed to pre for better formatting -->
        <pre id="statusMessageArea" class="mt-2 p-2 border rounded bg-light text-dark" style="min-height: 3em; white-space: pre-wrap; word-wrap: break-word;"></pre>
        <!-- Info text below buttons -->
        <div id="updateInfoText" class="small text-muted mt-1"></div>
      </div>
    </div>

    <!-- Add Containers heading -->
    <h4 class="mt-4 mb-3"><strong>Containers</strong></h4>

    <div id="tableView" class="table-responsive mb-4">
      <table id="metricsTable" class="table table-striped table-hover table-sm">
        <thead>
          <tr>
            <th class="col-name">🏷️ Name</th>
            <th class="col-cpu">⚙️ CPU %</th>
            <th class="col-ram">🧠 RAM %</th>
            <th class="col-pid">⚙️ Procs</th>
            <th class="col-memlimit">💾 Mem Limit (MB)</th>
            <th class="col-status">🚦 Status</th>
            <th class="col-uptime">⏱️ Uptime (D H M S)</th>
            <th class="col-netio">🌐 Net I/O (Rx/Tx MB)</th>
            <th class="col-blockio">💾 Block I/O (R/W MB)</th>
            <th class="col-image">🖼️ Image</th>
            <th class="col-ports">🔌 Ports</th>
            <th class="col-restarts">🔄 Restarts</th>
            <th class="col-logs">📜 Logs</th>
            <th class="col-charts">📊 Charts</th>
            <th class="col-ui">🌐 UI</th>
            <th class="col-update sortable" data-sort="update_available">⬆️ Update</th>
            <th class="col-actions">⚙️ Actions</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
      <div id="tableStatus" class="text-center text-muted mt-2"></div>
    </div>  <!-- End #tableView -->
    <!-- Chart Area -->
    <div id="chartContainer">
        <h5 id="chartTitle">Historical Usage</h5>
        <div id="chartControls">
            <div class="btn-group" role="group" aria-label="Chart type toggle">
                <input type="radio" class="btn-check" name="chartType" id="lineChartBtn" value="line" autocomplete="off" checked>
                <label class="btn btn-outline-primary btn-sm" for="lineChartBtn">Line Chart</label>

                <input type="radio" class="btn-check" name="chartType" id="barChartBtn" value="bar" autocomplete="off">
                <label class="btn btn-outline-primary btn-sm" for="barChartBtn">Bar Chart</label>
            </div>
        </div>
        <div class="text-center text-muted small">Use mouse wheel to zoom and pan the chart.</div>
        <canvas id="usageChart"></canvas>
        <div id="chartStatus">Select a container's 'Show Chart' button to view history.</div>
    </div>
    <!-- End Chart Area -->

  </div> <!-- End Main Container -->

  <!-- Footer -->
  <footer class="footer container-fluid">
    <p>DockerStats. Version 0.4.0</p>
  </footer>
  <!-- End Footer -->

  <!-- Bootstrap Bundle with Popper -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous"></script>

  <script>
    console.log("DEBUG: Script block started."); // <-- Added log
    // Register zoom plugin for Chart.js
    Chart.register(ChartZoom);
    // --- Global Variables ---
    const metricsTable = document.getElementById('metricsTable');
    const metricsTableBody = metricsTable.querySelector('tbody');
    const tableStatusDiv = document.getElementById('tableStatus'); // For 'Loading...' or 'No data' messages
    const tableDiv = document.getElementById('tableView');
    const themeToggleButton = document.getElementById('themeToggle'); // Selector remains valid
    const scrollTopButton = document.getElementById('scrollTop');
    const chartContainer = document.getElementById('chartContainer');
    const chartCanvas = document.getElementById('usageChart');
    const chartTitle = document.getElementById('chartTitle');
    const chartStatus = document.getElementById('chartStatus');
    const exportCsvBtn = document.getElementById('exportCsvBtn');
    const notifications = [];
    const notifBadge = document.getElementById('notifBadge'); // Selector remains valid
    const notifPanel = document.getElementById('notifPanel'); // Selector remains valid
    const notifList = document.getElementById('notifList');
    const navbarSearchInput = document.getElementById('navbarSearchInput'); // New search input
    const statusMessageArea = document.getElementById('statusMessageArea'); // <-- Add reference to status area
    let prevMetricsData = [];
    let refreshIntervalId = null; // To store the interval ID
    let REFRESH_INTERVAL_MS = 5000; // Default 5 seconds, now mutable
    let usageChart = null; // To store the Chart.js instance
    let currentChartContainerId = null; // Track which container's chart is shown
    let currentChartType = 'line'; // Default chart type
    let allMetricsData = []; // Store the full unfiltered data
    let searchDebounceTimer = null; // Timer for debouncing search input

    // --- Theme Management ---
    function applyTheme(theme) { // theme = 'light' or 'dark'
        document.body.setAttribute('data-bs-theme', theme);
        // Update button icon based on theme
        themeToggleButton.innerHTML = theme === 'dark' ? '☀️' : '🌙';
    }
    // Check preference, default to light if not set or invalid
    let currentTheme = localStorage.getItem('theme') || (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light');
    if (currentTheme !== 'dark' && currentTheme !== 'light') {
        currentTheme = 'light'; // Default to light if stored value is weird
    }
    applyTheme(currentTheme); // Apply initial theme

    themeToggleButton.onclick = () => {
      currentTheme = (currentTheme === 'light' ? 'dark' : 'light'); // Toggle state
      localStorage.setItem('theme', currentTheme); // Save preference
      applyTheme(currentTheme); // Apply the new theme
    };

    // --- Scroll to Top ---
    scrollTopButton.onclick = () => {
      window.scrollTo({ top: 0, behavior: 'smooth' });
    };

    // --- Column Visibility ---
    function applyColumnVisibility() {
        // Apply/remove hide classes on the TABLE element
        document.querySelectorAll('.column-toggles .form-check-input').forEach(toggle => {
            const columnKey = toggle.value;
            const cls = `hide-col-${columnKey}`;
            metricsTable.classList.toggle(cls, !toggle.checked);
        });

        // Update colspan for project rows after visibility changes
        updateProjectRowColspans();

        // Clear the status message if needed
        if (allMetricsData && allMetricsData.length > 0) {
            tableStatusDiv.textContent = '';
        }
    }

    function updateProjectRowColspans() {
        const currentVisibleCols = calculateVisibleColumns();
        document.querySelectorAll('.project-row td[colspan]').forEach(td => {
            td.setAttribute('colspan', currentVisibleCols);
        });
    }

    function calculateVisibleColumns() {
        let visibleColumnCount = 0;
        const tableClasses = metricsTable.classList;
        document.querySelectorAll('#metricsTable thead th').forEach(th => {
            const colClassIdentifier = [...th.classList].find(c => c.startsWith('col-'));
            if (colClassIdentifier) {
                const hideClass = `hide-${colClassIdentifier}`;
                if (!tableClasses.contains(hideClass)) {
                    visibleColumnCount++;
                }
            }
        });
        return Math.max(1, visibleColumnCount); // Ensure at least 1
    }

    document.querySelectorAll('.column-toggles .form-check-input').forEach(toggle => {
        // Load saved state
        const savedState = localStorage.getItem('colVisible-' + toggle.value);
        // Default to checked (visible) if no saved state, EXCEPT for 'ui' and 'update'
        const defaultChecked = !['ui', 'update'].includes(toggle.value);
        toggle.checked = savedState ? savedState === 'true' : defaultChecked;

        // Add listener
        toggle.addEventListener('change', () => {
            localStorage.setItem('colVisible-' + toggle.value, toggle.checked);
            applyColumnVisibility();
        });
    });

    let isFetching = false; // Prevent concurrent fetches
    async function fetchMetrics() {
        console.log("DEBUG: fetchMetrics called."); // <-- Added log
        if (isFetching) {
            console.log("DEBUG: Fetch already in progress, skipping.");
            return; // Don't start a new fetch if one is already running
        }
        isFetching = true;
        // Show loading indicator in table view
        tableStatusDiv.textContent = 'Loading...';

        const nameFilter = navbarSearchInput.value.toLowerCase().trim() || document.getElementById('filterName').value.toLowerCase().trim();
        const statusFilter = document.getElementById('filterStatus').value;
        const projectFilter = document.getElementById('filterProject').value;
        const range = document.getElementById('filterRange').value; // Still sent, backend history buffer uses it implicitly
        const sortBy = document.getElementById('sortBy').value; // Now might be 'uptime_sec'
        const sortDir = document.getElementById('sortDir').value;
        const maxItems = parseInt(document.getElementById('maxItems').value) || 0; // Default to 0 (no limit backend-side)

        // Build API URL (Points to the API route defined in routes.py)
        let url = `/api/metrics?sort=${sortBy}&dir=${sortDir}`;
        // Conditionally add filters only if they have a value
        if (nameFilter) url += `&name=${encodeURIComponent(nameFilter)}`;
        if (statusFilter) url += `&status=${encodeURIComponent(statusFilter)}`;
        if (projectFilter) url += `&project=${encodeURIComponent(projectFilter)}`;
        // Add max items parameter (the backend should handle this)
        if (maxItems > 0) url += `&max=${maxItems}`;
        // Add range for potential future backend use or debugging
        url += `&range=${range}`;

        console.log(`DEBUG: Fetching URL: ${url}`); // <-- Added log

        try {
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const data = await response.json();
            console.log(`DEBUG: Received ${data.length} rows from API.`); // <-- Added log
            allMetricsData = data; // Store the full data
            renderTable(data); // Render the potentially filtered/sorted data
            statusMessageArea.textContent = '';
        } catch (error) {
            console.error('Error fetching metrics:', error);
            tableStatusDiv.textContent = 'Error loading data.';
            statusMessageArea.textContent = 'Error during fetch or processing.'; // Update status on error
        } finally {
            isFetching = false; // Allow next fetch
            console.log("DEBUG: fetchMetrics finished."); // <-- Added log
        }
    }

    // Helper function for project toggle click
    function handleProjectToggle(event) {
        const btn = event.target;
        const proj = btn.dataset.project;
        const childRows = document.querySelectorAll(`.project-${proj}`);
        const isCollapsed = btn.textContent === '[+]';
        btn.textContent = isCollapsed ? '[-]' : '[+]';
        childRows.forEach(r => r.style.display = isCollapsed ? '' : 'none');
        // Save state
        localStorage.setItem('projectToggle-' + proj, isCollapsed ? 'open' : 'closed');
    }

    function renderTable(data) {
       metricsTableBody.innerHTML = '';
       tableStatusDiv.textContent = '';

       // Get the project filter value *before* processing data
       const projectFilterValue = document.getElementById('filterProject').value;

       // Filter data based on project filter *if* a filter is selected
       // NOTE: The backend already handles filtering and sorting.
       // This client-side filter might be redundant if the backend filter logic changes.
       // However, keeping it ensures consistency if the backend filter logic changes.
       const filteredData = projectFilterValue
           ? data.filter(d => d.compose_project === projectFilterValue || (!d.compose_project && projectFilterValue === ''))
           : data;

       if (!filteredData || filteredData.length === 0) {
           tableStatusDiv.textContent = 'No containers match filters or no data available.';
           return;
       }

       // Determine saved collapse state per project
       const projectStates = {};
       // Pre-calculate collapse states for all potential projects in the filtered data
       const uniqueProjects = [...new Set(filteredData.map(d => d.compose_project).filter(p => p))];
       uniqueProjects.forEach(proj => {
         const saved = localStorage.getItem('projectToggle-' + proj);
         projectStates[proj] = saved === 'closed'; // Default to open if not 'closed'
       });

       let currentProject = null; // Track the current project group being rendered
       let projectContainerCount = 0; // Track containers within the current project group
       let projectHasHeader = false; // Track if the current project header has been added
       let updateAvailableCount = 0; // Track available updates

       // --- Iterate through the already sorted data ---
       filteredData.forEach((d, index) => {
         // Increment update count if applicable
         if (d.update_available) {
             updateAvailableCount++;
         }

         const projectName = d.compose_project || null; // Use null for containers without a project

         // --- Project Header Logic ---
         // Check if the project has changed OR if it's the first container and has a project
         if (projectName !== currentProject) {
             // If we were previously rendering a project, reset count
             if (currentProject !== null) {
                 projectContainerCount = 0;
                 projectHasHeader = false;
             }
             currentProject = projectName;

             // Only add a header if the container belongs to a project
             if (currentProject !== null) {
                 // Count how many items belong to this new project in the *remaining* filtered data
                 // This is needed to decide if a header row is necessary (e.g., > 1 container)
                 // Note: This count might not be perfectly accurate if filtering hides items later,
                 // but it's a reasonable approach for header display.
                 const remainingInProject = filteredData.slice(index).filter(item => item.compose_project === currentProject).length;

                 // Show project header if more than one item in the project OR if filtering by this specific project
                 if (remainingInProject > 1 || projectFilterValue === currentProject) {
                     const effectiveColspan = calculateVisibleColumns();
                     const trProj = document.createElement('tr');
                     trProj.classList.add('project-row');
                     const collapsed = projectStates[currentProject] === true;
                     trProj.innerHTML = `
                       <td class="col-name" colspan="${effectiveColspan}">
                         <button class="btn btn-sm btn-link project-toggle" data-project="${currentProject}">${collapsed ? '[+]' : '[-]'}</button>
                         ${currentProject} (${remainingInProject})
                       </td>`;
                     metricsTableBody.appendChild(trProj);
                     projectHasHeader = true; // Mark that header was added
                 }
             }
         }

         // Increment count for the current project if it has one
         if (currentProject !== null) {
             projectContainerCount++;
         }
         // --- End Project Header Logic ---


         // --- Service/Container Row Rendering ---
         const tr = document.createElement('tr');
         // Add project class and manage visibility if it belongs to a project
         if (projectName) { // Check if projectName is not null/undefined
           tr.classList.add('child-row', `project-${projectName}`);
           // Hide if the project is collapsed AND a header was actually rendered for it
           if (projectHasHeader && projectStates[projectName] === true) {
               tr.style.display = 'none';
           } else {
               tr.style.display = ''; // Ensure it's visible otherwise
           }
         }

         const imageName = d.image || 'N/A';
         const portInfo = d.ports || 'N/A';
         const hostPort = portInfo.split('->')[0].split(':').pop();
         let baseHost = 'localhost';
         if (localStorage.getItem('useCustomIP') === 'true') {
             let raw = (localStorage.getItem('serverIP') || '').trim();
             raw = raw.split(/[,\s]+/)[0];
             raw = raw.replace(/\/$/, '');
             raw = raw.replace(/^https?:\/\//i, '');
             baseHost = raw || 'localhost';
         }
         const baseIP = baseHost;
         const uptimeText = d.uptime || 'N/A';
         const restartsText = (d.restarts !== null && d.restarts !== undefined) ? d.restarts : 'N/A';
         const netRxText = (d.net_io_rx !== null && d.net_io_rx !== undefined) ? d.net_io_rx.toFixed(2) : '-';
         const netTxText = (d.net_io_tx !== null && d.net_io_tx !== undefined) ? d.net_io_tx.toFixed(2) : '-';
         const blockRText = (d.block_io_r !== null && d.block_io_r !== undefined) ? d.block_io_r.toFixed(2) : '-';
         const blockWText = (d.block_io_w !== null && d.block_io_w !== undefined) ? d.block_io_w.toFixed(2) : '-';
         const cpuNum = Number(d.cpu) || 0;
         const cpuVal = cpuNum.toFixed(2);
         const cpuText = (d.cpu !== null && d.cpu !== undefined) ? `${cpuVal}%` : 'N/A';
         const cpuProgress = Math.max(0, Math.min(100, cpuNum));
         const memNum = Number(d.mem) || 0;
         const memVal = memNum.toFixed(2);
         const memText = (d.mem !== null && d.mem !== undefined) ? `${memVal}%` : 'N/A';
         const memProgress = Math.max(0, Math.min(100, memNum));
         tr.innerHTML = `
           <td class="col-name">${d.name || 'N/A'}</td>
           <td class="col-cpu">
             <span>${cpuText}</span>
             <div class="progress" role="progressbar" aria-label="CPU usage for ${d.name || 'container'}" aria-valuenow="${cpuProgress}" aria-valuemin="0" aria-valuemax="100">
               <div class="progress-bar bg-info text-bg-info" style="width: ${cpuProgress}%;"></div>
             </div>
           </td>
           <td class="col-ram">
             <span>${memText}</span>
             <div class="progress" role="progressbar" aria-label="Memory usage for ${d.name || 'container'}" aria-valuenow="${memProgress}" aria-valuemin="0" aria-valuemax="100">
               <div class="progress-bar bg-success text-bg-success" style="width: ${memProgress}%;"></div>
             </div>
           </td>
           <td class="col-pid">${d.pid_count !== null ? d.pid_count : 'N/A'}</td>
           <td class="col-memlimit">${d.mem_limit !== null ? d.mem_limit.toFixed(2) : 'N/A'}</td>
           <td class="col-status">${d.status || 'N/A'}</td>
           <td class="col-uptime">${uptimeText}</td>
           <td class="col-netio">${netRxText} / ${netTxText}</td>
           <td class="col-blockio">${blockRText} / ${blockWText}</td>
           <td class="col-image" title="${imageName}" style="max-width: 200px; overflow: hidden; text-overflow: ellipsis;">${imageName}</td>
           <td class="col-ports" title="${portInfo}" style="max-width: 250px; overflow: hidden; text-overflow: ellipsis;">${portInfo}</td>
           <td class="col-restarts">${restartsText}</td>
           <td class="col-logs"><a href="/logs/${d.id}" target="_blank">View Logs</a></td>
           <td class="col-charts">
             <button class="btn btn-outline-secondary btn-sm show-chart-btn" data-container-id="${d.id}" data-container-name="${d.name || 'Unknown'}">
               Show Chart 📈
             </button>
           </td>
           <td class="col-ui">
             <a href="http://${baseIP}:${hostPort}" target="_blank" class="btn btn-outline-primary btn-sm">Open UI</a>
           </td>
           <td class="col-update">
             ${d.update_available ? `⬆️` : ''}
           </td>
           <td class="col-actions">
             <button class="btn btn-outline-success btn-sm start-btn">Start</button>
             <button class="btn btn-outline-warning btn-sm stop-btn">Stop</button>
             <button class="btn btn-outline-danger btn-sm restart-btn">Restart</button>
           </td>
         `;
         metricsTableBody.appendChild(tr);
         // --- End Service/Container Row Rendering ---
       });

       // Update the info text with the count
       const updateInfoTextElement = document.getElementById('updateInfoText');
       if (updateInfoTextElement) {
           updateInfoTextElement.textContent = updateAvailableCount > 0 ? `(${updateAvailableCount} updates available)` : '';
       }

       // Add project toggle listeners AFTER all rows are added
       document.querySelectorAll('.project-toggle').forEach(btn => {
         btn.removeEventListener('click', handleProjectToggle); // Prevent duplicates
         btn.addEventListener('click', handleProjectToggle);
       });

       addChartButtonListeners();
       bindContainerButtons();
     }

    // --- Chart Functions ---
    function addChartButtonListeners() {
        // Listener for individual container history charts
        document.querySelectorAll('.show-chart-btn').forEach(button => {
            button.removeEventListener('click', handleShowHistoryChart); // Remove previous listener if any
            button.addEventListener('click', handleShowHistoryChart);
        });

        // Listener for comparison chart dropdown items - NOW OPENS NEW TAB
        document.querySelectorAll('.compare-action').forEach(action => {
            action.removeEventListener('click', handleOpenComparisonTab); // Remove previous listener
            action.addEventListener('click', handleOpenComparisonTab);
        });
    }

    function handleShowHistoryChart(event) {
        const containerId = event.target.dataset.containerId;
        const containerName = event.target.dataset.containerName;
        currentChartContainerId = containerId; // Store the selected container ID
        chartTitle.textContent = `Historical Usage for ${containerName} (${containerId.substring(0, 12)})`;
        chartContainer.style.display = 'block'; // Show the chart container
        document.getElementById('chartControls').style.display = 'block'; // Show line/bar toggle
        fetchAndRenderChart(); // Fetch data and render the HISTORY chart
        chartContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });
    }

    // NEW function to handle opening comparison charts in a new tab
    function handleOpenComparisonTab(event) {
        event.preventDefault(); // Prevent default link behavior
        const compareType = event.target.dataset.compareType;
        const topN = document.getElementById('compareTopN').value || 5; // Get Top N value
        const url = `/compare/${compareType}?topN=${topN}`; // Construct URL for the new route
        window.open(url, '_blank'); // Open the URL in a new tab
    }

    async function fetchAndRenderChart() {
        if (!currentChartContainerId) return; // Don't fetch if no container is selected

        const range = document.getElementById('filterRange').value;
        const url = `/api/history/${currentChartContainerId}?range=${range}`;
        chartStatus.textContent = 'Loading chart data...';
        chartStatus.style.color = 'var(--bs-secondary-color)'; // Reset color

        try {
            const response = await fetch(url, { credentials: 'include' });
            if (!response.ok) {
                console.error("Failed to fetch history:", response.status, await response.text());
                chartStatus.textContent = `Error loading chart data (Status: ${response.status}).`;
                chartStatus.style.color = 'var(--bs-danger)';
                if (usageChart) {
                    usageChart.destroy(); // Clear existing chart on error
                    usageChart = null;
                }
                return;
            }
            const historyData = await response.json();
            renderChart(historyData);

        } catch (error) {
            console.error("Error fetching or processing chart data:", error);
            chartStatus.textContent = 'Network or processing error loading chart data.';
            chartStatus.style.color = 'var(--bs-danger)';
             if (usageChart) {
                usageChart.destroy();
                usageChart = null;
            }
        }
    }

    function renderChart(historyData) {
        if (!historyData || !historyData.timestamps || historyData.timestamps.length === 0) {
            chartStatus.textContent = 'No historical data available for the selected range.';
            if (usageChart) {
                usageChart.destroy();
                usageChart = null;
            }
            return;
        }

        chartStatus.textContent = ''; // Clear status message

        const labels = historyData.timestamps.map(ts => new Date(ts * 1000).toLocaleString()); // Format timestamps
        const cpuData = historyData.cpu_usage;
        const ramData = historyData.ram_usage;

        const datasets = [
            {
                label: 'CPU Usage (%)',
                data: cpuData,
                borderColor: 'rgb(54, 162, 235)', // Blue
                backgroundColor: 'rgba(54, 162, 235, 0.5)',
                tension: 0.1, // For line chart smoothness
                fill: currentChartType === 'line' ? false : true, // Fill for bar, not line
            },
            {
                label: 'RAM Usage (%)',
                data: ramData,
                borderColor: 'rgb(75, 192, 192)', // Green
                backgroundColor: 'rgba(75, 192, 192, 0.5)',
                tension: 0.1,
                fill: currentChartType === 'line' ? false : true,
            }
        ];

        const config = {
            type: currentChartType, // 'line' or 'bar'
            data: {
                labels: labels,
                datasets: datasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false, // Allow chart to fill container height
                animation: {
                    duration: 500 // Shorter animation
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        min: 0,
                        max: 100, // Assuming percentage
                        title: {
                            display: true,
                            text: 'Usage (%)'
                        }
                    },
                    x: {
                        title: {
                            display: true,
                            text: 'Time'
                        },
                        ticks: {
                            maxRotation: 70, // Rotate labels if they overlap
                            minRotation: 0,
                            autoSkip: true, // Skip labels automatically if too dense
                            maxTicksLimit: 20 // Limit number of visible ticks
                        }
                    }
                },
                plugins: {
                    legend: {
                        position: 'top',
                    },
                    tooltip: {
                        mode: 'index',
                        intersect: false,
                    },
                    zoom: {
                        zoom: { wheel: { enabled: true }, pinch: { enabled: true }, mode: 'xy' },
                        pan: { enabled: true, mode: 'xy' }
                    }
                },
                hover: { // Performance optimization for large datasets
                    mode: 'nearest',
                    intersect: true
                }
            }
        };

        // Destroy previous chart instance if it exists
        if (usageChart) {
            usageChart.destroy();
        }

        // Create new chart
        usageChart = new Chart(chartCanvas, config);
    }

    // Función para guardar todos los ajustes en localStorage
    function saveSettings() {
      // Persist project toggle states
      document.querySelectorAll('.project-toggle').forEach(btn => {
        const proj = btn.dataset.project;
        const open = btn.textContent === '[-]';
        localStorage.setItem('projectToggle-' + proj, open ? 'open' : 'closed');
      });
      const ids = ['filterName','filterStatus','filterRange','sortBy','sortDir','maxItems', 'refreshInterval']; // Added refreshInterval
      ids.forEach(id => localStorage.setItem(id, document.getElementById(id).value));
      localStorage.setItem('chartType', currentChartType);
      localStorage.setItem('theme', currentTheme);
      // Save server IP settings
      localStorage.setItem('serverIP', document.getElementById('serverIP').value);
      localStorage.setItem('useCustomIP', document.getElementById('useCustomIP').checked);
      // Guardar columnas visibles
      document.querySelectorAll('.column-toggles .form-check-input').forEach(input => {
        localStorage.setItem(input.id, input.checked);
      });
      // Show message in status area instead of alert
      statusMessageArea.textContent = 'Settings saved ✅';
      statusMessageArea.style.color = '#7a49cd';
    }

    // Toggle all column visibility
    function toggleAllColumns() {
      const inputs = document.querySelectorAll('.column-toggles .form-check-input');
      const anyChecked = Array.from(inputs).some(i => i.checked);
      inputs.forEach(i => {
        i.checked = anyChecked ? false : true;
        localStorage.setItem(i.id, i.checked);
      });
      applyColumnVisibility();
    }

    // --- Export & Container Controls ---
    function getSelectedMetrics() {
      return Array.from(metricsTableBody.querySelectorAll('tr')).map(tr => ({
        id: tr.querySelector('.show-chart-btn')?.dataset.containerId || '',
        name: tr.querySelector('.col-name')?.textContent || '',
        cpu: tr.querySelector('.col-cpu span')?.textContent.replace('%','') || '',
        ram: tr.querySelector('.col-ram span')?.textContent.replace('%','') || '',
        status: tr.querySelector('.col-status')?.textContent || '',
        uptime: tr.querySelector('.col-uptime')?.textContent || ''
      }));
    }

    function bindContainerButtons() {
        // Use event delegation for better reliability
        metricsTableBody.addEventListener('click', async (event) => {
            const btn = event.target;
            if (!btn.classList.contains('action-btn') && !btn.classList.contains('update-btn') && !btn.classList.contains('start-btn') && !btn.classList.contains('stop-btn') && !btn.classList.contains('restart-btn')) return;
            let action, containerId, containerName;
            if (btn.classList.contains('update-btn')) {
                action = 'update';
                containerId = btn.dataset.containerId;
                containerName = btn.closest('tr').querySelector('.col-name')?.textContent || containerId?.substring(0, 12) || '';
            } else if (btn.classList.contains('start-btn')) {
                action = 'start';
                containerId = btn.closest('tr').querySelector('.show-chart-btn')?.dataset.containerId;
                containerName = btn.closest('tr').querySelector('.col-name')?.textContent || containerId?.substring(0, 12) || '';
            } else if (btn.classList.contains('stop-btn')) {
                action = 'stop';
                containerId = btn.closest('tr').querySelector('.show-chart-btn')?.dataset.containerId;
                containerName = btn.closest('tr').querySelector('.col-name')?.textContent || containerId?.substring(0, 12) || '';
            } else if (btn.classList.contains('restart-btn')) {
                action = 'restart';
                containerId = btn.closest('tr').querySelector('.show-chart-btn')?.dataset.containerId;
                containerName = btn.closest('tr').querySelector('.col-name')?.textContent || containerId?.substring(0, 12) || '';
            } else if (btn.classList.contains('action-btn')) {
                action = btn.dataset.action;
                containerId = btn.dataset.id;
                containerName = btn.dataset.name || containerId?.substring(0, 12) || '';
            } else {
                return;
            }
            if (!containerId || !action) return;
            const url = `/api/containers/${containerId}/${action}`;
            btn.disabled = true;
            statusMessageArea.textContent = `Starting '${action}' for ${containerName}...\n`;
            statusMessageArea.style.color = '#7a49cd';
            try {
                const response = await fetch(url, { method: 'POST' });
                if (action === 'update' && response.ok && response.headers.get('content-type')?.includes('text/plain')) {
                    statusMessageArea.textContent = `Updating ${containerName}...\n`;
                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    let hadOutput = false;
                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;
                        const chunk = decoder.decode(value, { stream: true });
                        if (chunk) {
                            statusMessageArea.textContent += chunk;
                            statusMessageArea.scrollTop = statusMessageArea.scrollHeight;
                            hadOutput = true;
                        }
                    }
                    if (!hadOutput) {
                        statusMessageArea.textContent += '\nNo output received from update operation.';
                    }
                    statusMessageArea.textContent += '\nUpdate process finished.';
                    setTimeout(fetchMetrics, 1000);
                } else {
                    let result = null;
                    let text = '';
                    try {
                        text = await response.text();
                        result = JSON.parse(text);
                    } catch (e) {
                        // Not JSON, fallback to text
                    }
                    if (!response.ok) {
                        statusMessageArea.textContent = result?.error ? `Error: ${result.error}` : `Error: ${text || 'Unknown error'}`;
                        statusMessageArea.style.color = 'red';
                    } else {
                        let msg = result?.status || text || `Action '${action}' completed successfully.`;
                        statusMessageArea.textContent = msg;
                        statusMessageArea.style.color = '#7a49cd';
                        fetchMetrics();
                    }
                }
            } catch (error) {
                statusMessageArea.textContent = `Network or server error: ${error.message}`;
                statusMessageArea.style.color = 'red';
            } finally {
                btn.disabled = false;
            }
        });
    }

    // Export CSV handler
    exportCsvBtn.addEventListener('click', () => {
      const data = getSelectedMetrics();
      fetch('/api/export/csv', {
        method: 'POST',
        headers: {'Content-Type':'application/json'},
        body: JSON.stringify({metrics: data}),
        credentials: 'include'
      })
      .then(res => res.blob())
      .then(blob => {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'metrics.csv';
        a.click();
        URL.revokeObjectURL(url);
      });
    });

    // --- Notification Functions ---
    function addNotification(type, containerName, containerId) {
      const timestamp = new Date();
      notifications.push({type, containerName, containerId, timestamp});
      updateNotifBadge();
      // Only render if panel is already visible
      const notifPanelElement = document.getElementById('notifPanel'); // Get panel element
      if (notifPanelElement && notifPanelElement.style.display === 'block') {
        renderNotifList();
      }
    }

    function updateNotifBadge() {
      if (notifications.length > 0) {
        notifBadge.textContent = notifications.length;
        notifBadge.style.display = 'inline-block';
      } else {
        notifBadge.style.display = 'none';
      }
    }

    function renderNotifList() {
      if (notifications.length === 0) {
        notifList.innerHTML = '<p class="small text-muted">No notifications</p>';
        return;
      }
      notifList.innerHTML = notifications.map(n => {
        const time = n.timestamp.toLocaleTimeString();
        return `<div class="notif-item"><strong>${n.type}</strong> ${n.containerName} at ${time}</div>`;
      }).join('');
    }

    function checkNotifications(data) {
      data.forEach(d => {
        const prev = prevMetricsData.find(p => p.id === d.id);
        // CPU notification: prevCpu defaults to 0 if first run
        const cpu = Number(d.cpu) || 0;
        const prevCpu = prev ? (Number(prev.cpu) || 0) : 0;
        const cpuThresh = Number(document.getElementById('notifCpuThreshold').value) || 0;
        if (cpu >= cpuThresh && prevCpu < cpuThresh) {
          addNotification('CPU', d.name, d.id);
        }
        // RAM notification
        const mem = Number(d.mem) || 0;
        const prevMem = prev ? (Number(prev.mem) || 0) : 0;
        const memThresh = Number(document.getElementById('notifRamThreshold').value) || 0;
        if (mem >= memThresh && prevMem < memThresh) {
          addNotification('RAM', d.name, d.id);
        }
        // Status change notification only when previous status exists
        const statusChangeEnabled = document.getElementById('notifStatusChange').checked;
        if (prev && statusChangeEnabled && d.status !== prev.status) {
          addNotification('Status', `${d.name} (${prev.status}→${d.status})`, d.id);
        }
      });
      prevMetricsData = JSON.parse(JSON.stringify(data));
    }

    // --- Initial Load & Event Listeners ---
    document.addEventListener('DOMContentLoaded', () => {
      try {
        // Load persisted controls
        const savedName = localStorage.getItem('filterName');
        if (savedName) document.getElementById('filterName').value = savedName;
        const savedStatus = localStorage.getItem('filterStatus');
        if (savedStatus) document.getElementById('filterStatus').value = savedStatus;
        const savedRange = localStorage.getItem('filterRange');
        if (savedRange) document.getElementById('filterRange').value = savedRange;
        const savedSortBy = localStorage.getItem('sortBy');
        if (savedSortBy) document.getElementById('sortBy').value = savedSortBy;
        const savedSortDir = localStorage.getItem('sortDir');
        if (savedSortDir) document.getElementById('sortDir').value = savedSortDir;
        const savedMax = localStorage.getItem('maxItems');
        if (savedMax) document.getElementById('maxItems').value = savedMax;

        // Load saved refresh interval
        const savedInterval = localStorage.getItem('refreshInterval');
        const refreshIntervalSelect = document.getElementById('refreshInterval');
        if (savedInterval) {
            refreshIntervalSelect.value = savedInterval;
            REFRESH_INTERVAL_MS = parseInt(savedInterval, 10);
        } else {
            // Use default if nothing saved
            REFRESH_INTERVAL_MS = parseInt(refreshIntervalSelect.value, 10);
        }

        const savedProject = localStorage.getItem('filterProject');
        // Populate project dropdown
        fetch('/api/projects', { credentials: 'include' })
          .then(res => res.json())
          .then(projects => {
            const sel = document.getElementById('filterProject');
            projects.forEach(p => {
                const opt = document.createElement('option'); opt.value = p; opt.textContent = p;
                sel.appendChild(opt);
            });
            if (savedProject) sel.value = savedProject;
          });
        // On change, persist and fetch
        const projEl = document.getElementById('filterProject');
        projEl.addEventListener('change', e => {
            localStorage.setItem('filterProject', e.target.value);
            fetchMetrics();
        });
        // Load saved server IP and custom IP toggle
        const savedIP = localStorage.getItem('serverIP');
        if (savedIP) document.getElementById('serverIP').value = savedIP;
        const savedUseCustom = localStorage.getItem('useCustomIP');
        if (savedUseCustom !== null) document.getElementById('useCustomIP').checked = (savedUseCustom === 'true');
        const savedChartType = localStorage.getItem('chartType');
        if (savedChartType) {
            document.getElementById(savedChartType + 'ChartBtn').checked = true;
            currentChartType = savedChartType;
        }
        // Cargar estado guardado de columnas y aplicar visibilidad inicial
        document.querySelectorAll('.column-toggles .form-check-input').forEach(input => {
          const saved = localStorage.getItem(input.id);
          // Default to checked (visible) if no saved state, EXCEPT for specific columns like 'ui', 'update', etc.
          const defaultChecked = !['netio', 'blockio', 'image', 'ports', 'restarts', 'ui', 'update'].includes(input.value);
          if (input.value === 'name') { // Ensure Name is always checked and disabled
              input.checked = true;
              input.disabled = true;
          } else {
              input.checked = saved ? (saved === 'true') : defaultChecked;
          }
          // Apply initial class to table based on loaded state
          const columnClass = `hide-col-${input.value}`;
          metricsTable.classList.toggle(columnClass, !input.checked);
        });

        // Añadir listener para el botón de guardar ajustes
        document.getElementById('saveSettingsBtn').addEventListener('click', saveSettings);
        document.getElementById('toggleColsBtn').addEventListener('click', toggleAllColumns);

        // Add listeners to all filter/control elements
        document.querySelectorAll('#filterName, #filterStatus, #filterRange, #sortBy, #sortDir, #refreshInterval')
            .forEach(el => {
                el.addEventListener('change', fetchMetrics);
                el.addEventListener('change', e => localStorage.setItem(e.target.id, e.target.value));
            });
        // maxItems persistence and fetch
        const maxEl = document.getElementById('maxItems');
        maxEl.addEventListener('change', e => { localStorage.setItem('maxItems', e.target.value); fetchMetrics(); });

        // Add listener for refresh interval changes
        const refreshIntervalSelectEl = document.getElementById('refreshInterval');
        refreshIntervalSelectEl.addEventListener('change', e => {
            const newInterval = parseInt(e.target.value, 10);
            localStorage.setItem('refreshInterval', newInterval);
            REFRESH_INTERVAL_MS = newInterval;
            console.log(`Refresh interval changed to ${REFRESH_INTERVAL_MS / 1000} seconds.`);
            // Clear existing interval and set a new one
            if (refreshIntervalId) {
                clearInterval(refreshIntervalId);
            }
            fetchMetrics(); // Fetch immediately after changing interval
            refreshIntervalId = setInterval(() => fetchMetrics(false), REFRESH_INTERVAL_MS);
        });

        // Add listener for the new navbar search input with debouncing
        navbarSearchInput.addEventListener('input', () => {
            clearTimeout(searchDebounceTimer);
            searchDebounceTimer = setTimeout(() => {
                fetchMetrics(); // Fetch data after user stops typing for 300ms
            }, 300);
        });

        fetchMetrics(); // Initial load is not triggered by check updates

        // Set interval for periodic refresh
        if (refreshIntervalId) { clearInterval(refreshIntervalId); } // Clear previous interval if any
        refreshIntervalId = setInterval(() => fetchMetrics(false), REFRESH_INTERVAL_MS); // Use the potentially loaded interval

        // Set initial project toggle states
        document.querySelectorAll('.project-toggle').forEach(btn => {
          const proj = btn.dataset.project;
          const savedState = localStorage.getItem('projectToggle-' + proj);
          const isCollapsed = savedState === 'closed';
          btn.textContent = isCollapsed ? '[+]' : '[-]';
          const childRows = document.querySelectorAll(`.project-${proj}`);
          childRows.forEach(r => r.style.display = isCollapsed ? 'none' : '');
        });

        // Add listener for Range changes to update the chart if visible
        document.getElementById('filterRange').addEventListener('change', () => {
            if (chartContainer.style.display === 'block' && currentChartContainerId) {
                fetchAndRenderChart();
            } else {
                // If range changes but no chart is active, just fetch table data
                fetchMetrics();
            }
        });

        // Add listeners for chart type toggle buttons
        document.querySelectorAll('input[name="chartType"]').forEach(radio => {
            radio.addEventListener('change', (event) => {
                currentChartType = event.target.value;
                localStorage.setItem('chartType', event.target.value);
                if (usageChart) fetchAndRenderChart();
            });
        });

        // Add click handlers on column headers to sort table
        (function addHeaderSorting() {
            const sortByEl = document.getElementById('sortBy');
            const sortDirEl = document.getElementById('sortDir');
            // Map column class suffix to the sort key used in the API
            const headerSortMap = {
                name: 'name',
                cpu: 'cpu',
                ram: 'mem',
                pid: 'pid_count', // Added mapping for Procs column
                status: 'status',
                uptime: 'uptime_sec',
                restarts: 'restarts',
                combined: 'combined', // This isn't a header, but kept for reference
                memlimit: 'mem_limit_mb', // Added
                netio: 'net_io_rx',      // Added (sorts by Rx)
                blockio: 'block_io_r',   // Added (sorts by Read)
                update: 'update_available' // Added
            };
            document.querySelectorAll('#metricsTable thead th').forEach(th => {
                const colClass = [...th.classList].find(c => c.startsWith('col-'));
                if (!colClass) return;
                const key = colClass.replace('col-', '');
                const sortKey = headerSortMap[key];
                if (!sortKey) return;
                th.style.cursor = 'pointer';
                th.addEventListener('click', () => {
                    if (sortByEl.value === sortKey) {
                        sortDirEl.value = sortDirEl.value === 'asc' ? 'desc' : 'asc';
                    } else {
                        sortByEl.value = sortKey;
                        sortDirEl.value = 'desc';
                    }
                    localStorage.setItem('sortBy', sortByEl.value);
                    localStorage.setItem('sortDir', sortDirEl.value);
                    fetchMetrics();
                });
            });
        })();

        // Load saved notification settings
        document.getElementById('notifCpuThreshold').value = localStorage.getItem('notifCpuThreshold') || 80;
        document.getElementById('notifRamThreshold').value = localStorage.getItem('notifRamThreshold') || 80;
        document.getElementById('notifStatusChange').checked = localStorage.getItem('notifStatusChange') === 'true';

        // Setup notification toggle button
        document.getElementById('notifToggle').addEventListener('click', (event) => {
          event.stopPropagation(); // Prevent click from closing panel immediately if bubbling
          const notifPanelElement = document.getElementById('notifPanel'); // Get panel element
          const isVisible = notifPanelElement.style.display === 'block';
          notifPanelElement.style.display = isVisible ? 'none' : 'block';
          if (!isVisible) { // If panel was just opened
            renderNotifList(); // Render the current list
            notifications.length = 0; // Clear notifications (mark as read)
            updateNotifBadge(); // Update badge count
          }
        });
        // Close notification panel if clicking outside
        document.addEventListener('click', (event) => {
            const notifPanelElement = document.getElementById('notifPanel');
            const notifToggleElement = document.getElementById('notifToggle');
            // Check if the click is outside the panel AND outside the toggle button
            if (notifPanelElement && notifToggleElement && !notifPanelElement.contains(event.target) && !notifToggleElement.contains(event.target)) {
                notifPanelElement.style.display = 'none';
            }
        });

        // Clear notifications
        document.getElementById('clearNotifsBtn').addEventListener('click', () => {
          notifications.length = 0;
          renderNotifList();
          updateNotifBadge();
        });

        // Save notification settings
        document.getElementById('saveNotifSettingsBtn').addEventListener('click', () => {
          localStorage.setItem('notifCpuThreshold', document.getElementById('notifCpuThreshold').value);
          localStorage.setItem('notifRamThreshold', document.getElementById('notifRamThreshold').value);
          localStorage.setItem('notifStatusChange', document.getElementById('notifStatusChange').checked);
          // Reset previous metrics so new thresholds will trigger
          prevMetricsData = [];
          // Show message in status area instead of alert
          statusMessageArea.textContent = 'Notification settings saved ✅';
          statusMessageArea.style.color = '#7a49cd';
        });

        document.getElementById('checkUpdatesBtn').addEventListener('click', async () => {
          statusMessageArea.textContent = 'Checking update...';
          statusMessageArea.style.color = '#7a49cd';
          try {
            await fetchMetrics();
            statusMessageArea.textContent = 'Update check complete.';
            statusMessageArea.style.color = '#7a49cd';
          } catch (e) {
            statusMessageArea.textContent = 'Error during update check.';
            statusMessageArea.style.color = 'red';
          }
        });

        console.log(`Docker Monitor UI Initialized. Refreshing every ${REFRESH_INTERVAL_MS / 1000} seconds.`);
      } catch (e) {
        console.error('Init error', e);
        statusMessageArea.textContent = 'Initialization error. Check console.'; // Show init error
      }
    });

  </script>
</body>
</html>